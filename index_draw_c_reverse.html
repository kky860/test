<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>섞어짜기 선그리기</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <style>
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        /* 2. Remove default margin */
        * {
            margin: 0;
        }
    </style>
</head>

<body>
    <script>
        let points = [];
        const gridSize = 60;
        const radius = 6;
        let draggingPoint = null;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            angleMode(RADIANS);
            strokeCap(ROUND);
            noFill();
        }

        function draw() {
            background(245);
            drawGrid();

            // 점 그리기
            noStroke();
            fill(0);
            for (let pt of points) {
                circle(pt.x, pt.y, radius * 2);
            }

            // 연결 그리기
            stroke(0);
            strokeWeight(2);
            noFill();
            for (let i = 1; i < points.length; i++) {
                drawSmartConnection(points[i - 1], points[i]);
            }

            // 드래그 중이면 스냅
            if (draggingPoint) {
                draggingPoint.x = round(mouseX / gridSize) * gridSize;
                draggingPoint.y = round(mouseY / gridSize) * gridSize;
            }
        }

        function mousePressed() {
            const gx = round(mouseX / gridSize) * gridSize;
            const gy = round(mouseY / gridSize) * gridSize;

            if (keyIsDown(SHIFT)) {
                for (let i = points.length - 1; i >= 0; i--) {
                    if (dist(mouseX, mouseY, points[i].x, points[i].y) < radius * 2) {
                        points.splice(i, 1);
                        return;
                    }
                }
            } else {
                for (let pt of points) {
                    if (dist(mouseX, mouseY, pt.x, pt.y) < radius) {
                        draggingPoint = pt;
                        return;
                    }
                }
                points.push({ x: gx, y: gy });
            }
        }

        function mouseReleased() {
            draggingPoint = null;
        }

        function drawGrid() {
            stroke(230);
            strokeWeight(1);
            for (let x = 0; x <= width; x += gridSize) {
                line(x, 0, x, height);
            }
            for (let y = 0; y <= height; y += gridSize) {
                line(0, y, width, y);
            }
        }

        // ✅ 지능적 연결
        function drawSmartConnection(p0, p1) {
            const dx = p1.x - p0.x;
            const dy = p1.y - p0.y;

            if (abs(dx) === gridSize && abs(dy) === gridSize) {
                drawDoubleArc(p0, p1, 4);
            } else {
                drawDoubleLine(p0, p1, 4);
            }
        }

        // ✅ 두 줄 라인
        function drawDoubleLine(p0, p1, gap) {
            const angle = atan2(p1.y - p0.y, p1.x - p0.x);
            const offsetX = (gap / 2) * cos(angle + HALF_PI);
            const offsetY = (gap / 2) * sin(angle + HALF_PI);

            line(p0.x - offsetX, p0.y - offsetY, p1.x - offsetX, p1.y - offsetY);
            line(p0.x + offsetX, p0.y + offsetY, p1.x + offsetX, p1.y + offsetY);
        }

        // ✅ 두 줄 아크
        function drawDoubleArc(p0, p1, gap) {
            let cx, cy, start, end;

            const dx = p1.x - p0.x;
            const dy = p1.y - p0.y;

            if (dx > 0 && dy > 0) {         // ↘
                cx = p0.x;
                cy = p1.y;
                start = PI + HALF_PI;
                end = TWO_PI;
            } else if (dx < 0 && dy > 0) {  // ↙
                cx = p1.x;
                cy = p0.y;
                start = 0;
                end = HALF_PI;
            } else if (dx < 0 && dy < 0) {  // ↖
                cx = p0.x;
                cy = p1.y;
                start = HALF_PI;
                end = PI;
            } else if (dx > 0 && dy < 0) {  // ↗
                cx = p1.x;
                cy = p0.y;
                start = PI;
                end = PI + HALF_PI;
            }

            const baseDiameter = gridSize * 2;
            const offset = gap;  // 전체 간격 기준

            // 반지름을 약간 다르게 해서 겹침 방지
            arc(cx, cy, baseDiameter - offset, baseDiameter - offset, start, end);
            arc(cx, cy, baseDiameter + offset, baseDiameter + offset, start, end);
        }
    </script>
</body>

</html>